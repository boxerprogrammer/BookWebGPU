<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<title>WebGPU Life</title>
	</head>
	<body>
		<canvas width="512" height="512"></canvas>
		<script type="module">
			const GRID_SIZE=64;
			const UPDATE_INTERVAL=180;
			const WORKGROUP_SIZE=8;

			let step=0;
			//WebGPUのグラフィクスを書き出すためのキャンバスの取得
			const canvas=document.querySelector("canvas");
			
			//アダプターとデバイスをリクエストする
			//WebGPUのためのインターフェースを取得
			if(!navigator.gpu){
				//ブラウザがWebGPUに対応してなければ例外発生
				throw new Error("WebGPUはこのブラウザでサポートされていません");
			}
			//アダプターのリクエスト
			//requestAdapterはPromiseで返ってくるため、awaitで待っておく
			//https://developer.mozilla.org/en-US/docs/Web/API/GPU/requestAdapter
			const adapter = await navigator.gpu.requestAdapter();
			if(!adapter){
				throw new Error("適切なGPUアダプタ(対応グラボ)がありません");
			}

			//デバイスのリクエスト
			//https://developer.mozilla.org/en-US/docs/Web/API/GPUAdapter/requestDevice
			const dev = await adapter.requestDevice();
			if(!dev){
				throw new Error("デバイスの取得に失敗しました");
			}

			//ここでWebGPU用のコンテキストを取得する
			const context=canvas.getContext("webgpu");
			//現在のGPUキャンバスにとって最適なフォーマットを返す
			//https://developer.mozilla.org/en-US/docs/Web/API/GPU/getPreferredCanvasFormat
			const canvasFormat = navigator.gpu.getPreferredCanvasFormat();

			//頂点の定義
			//Zの字に定義する(N字でもOK)
			// const vertices = new Float32Array([
			// 	-0.5, 0.5,//左上
			// 	0.5, 0.5,//右上
			// 	-0.5, -0.5,//左下
			// 	0.5, -0.5,//右下
			// ]);
			const vertices = new Float32Array([
				//   X,    Y,
				-0.8, -0.8, // Triangle 1 (Blue)
				0.8, -0.8,
				0.8,  0.8,

				-0.8, -0.8, // Triangle 2 (Red)
				0.8,  0.8,
				-0.8,  0.8,
			]);




			//上の頂点データを入れるための頂点バッファをGPU上(VRAM上)に確保する
			//https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createBuffer
			//https://developer.mozilla.org/en-US/docs/Web/API/GPUBuffer/usage
			const vertexBuffer = dev.createBuffer({
				label : "Cell vertices",
				size : vertices.byteLength,//バッファーのサイズ
				//VERTEX=頂点バッファとして使う、COPY_DST=コピーや書き込み先として使う
				usage : GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
			});

			//GPU上の頂点バッファに頂点データを書き込む
			//https://developer.mozilla.org/en-US/docs/Web/API/GPUQueue/writeBuffer
			//引数は、書き込み先バッファ、オフセット、データ元、データオフセット(オプション)、書き込みサイズ(オプション)
			dev.queue.writeBuffer(vertexBuffer,0,vertices);

			//ユニフォームバッファ(DirectXで言う所のConstantBuffer)を作る
			const uniformArray = new Float32Array([GRID_SIZE,GRID_SIZE]);
			const uniformBuffer = dev.createBuffer({
				label:"Grid Uniforms",
				size : uniformArray.byteLength,//バッファのサイズ
				//UNIFORM=ユニフォームバッファとして使う、COPY_DST=コピーや書き込み先として使う
				usage : GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
			});
			dev.queue.writeBuffer(uniformBuffer,0,uniformArray);

			//次はコンピュートシェーダ用の「ストレージバッファ」を作る
			//DirectXで言う所のUnorderedAccessBufferみたいなもんか？
			const cellStateArray = new Uint32Array(GRID_SIZE*GRID_SIZE);
			const cellStateStorages = [
				dev.createBuffer({
					labrl : "Cell State A",
					size : cellStateArray.byteLength,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
				}),
				dev.createBuffer({
					labrl : "Cell State B",
					size : cellStateArray.byteLength,
					usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST
				})
			];

			//3つごとのセルをONにする
			for(let i=0;i<cellStateArray.length; i+=3){
				cellStateArray[i]=Math.random()>0.4?1:0;
			}
			dev.queue.writeBuffer(cellStateStorages[0],0,cellStateArray);
			


			//VertexBufferLayoutディクショナリをここで設定しておくことで、レンダリングパイプライン
			//設定の時にlayoutを"auto"にしたときに、これに合わせてレイアウトしてくれるようになる
			//これをやらない場合は、自前でレイアウトオブジェクトを作成することになり面倒くさい。
			//https://gpuweb.github.io/gpuweb/#dictdef-gpuvertexbufferlayout
			//https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createPipelineLayout
			const vertexBufferLayout={
				arrayStride : 8,//１頂点当たり何バイトか
				attributes:[
					{
						//頂点形式https://gpuweb.github.io/gpuweb/#enumdef-gpuvertexformat を参照の事
						format : "float32x2",//今回はfloat2つ(x,y)ぶん
						offset : 0,//構造体の先頭からその属性までのオフセットをバイト単位で
						shaderLocation:0,//この属性に関連付けられたインデックス、@locationに対応
					}
				]
			};

			//「シェーダモジュール」を生成する(WGSLオブジェクト)
			//https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createShaderModule
			//@vertex：シェーダステージを表す
			//https://www.w3.org/TR/WGSL/#shader-stages-sec
			//@builtin : 元々組み込まれている情報の種類(恐らく頂点レイアウトに関わらずレンダリングパイプラインに関わるデータ)
			//@builtin(position)なら座標、@builtin(vertex_index)なら頂点インデックスを表す
			//@builtin(instance_index)なら、インスタンスのインデックスを表す
			//WGSLの文法はRustに近いため慣れが必要
			//fn 関数名(引数) -> 戻り値 の形
			const cellShaderModule = dev.createShaderModule({
				label:"Cell shader",//後々のデバッグで識別するためのラベル文字列
				code : `

						struct VertexInput{
							@location(0) pos:vec2f,
							@builtin(instance_index) instance:u32
						};
						struct VertexOutput{
							@builtin(position) pos:vec4f,
							@location(0) cell:vec2f
						};
						@group(0) @binding(0) var<uniform> grid : vec2f;
						@group(0) @binding(1) var<storage> cellState:array<u32>;
						@vertex
						fn vertexMain(input:VertexInput) -> VertexOutput 
						{
							let i= f32(input.instance);
							let cell=vec2f(i%grid.x,floor(i/grid.x));//
							let state=f32(cellState[input.instance]);

							let cellOffset=cell/grid*2;
							
							let gridPos = (input.pos*state+1)/grid -1 + cellOffset;
							
							var output:VertexOutput;
							output.pos=vec4f(gridPos,0,1);
							output.cell = cell/grid;
							return output;
						}
						
						@fragment
						fn fragmentMain(input : VertexOutput) -> @location(0) vec4f{
							let col = input.cell;
							return vec4f(col,1-col.x,1);
						}
						`//シェーダコード文字列
			});

			//コンピュートシェーダコード
			//ワークグループサイズについては
			//https://www.w3.org/TR/WGSL/#ref-for-attribute-workgroup_size%E2%91%A2
			//を参照の事。x,y,zの3種類が設定できるが、設定していない部分(ここではz)は自動的に
			//１に指定される(それについてはhttps://www.w3.org/TR/WGSL/#attributes に記載アリ)
			//なお、JavaScriptでは文字列中に${定数名}を記述すると、呼び出し時点でのその値が適用される
			//仕様(テンプレートリテラル)があります。
			//https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Template_literals
			//なお、global_invocation_idは
			//https://www.w3.org/TR/WGSL/#global-invocation-id-builtin-value
			//によれば、スレッドごとのユニークな通し番号で、HLSLで言う所のSV_DispatchThreadIDと同様と
			//思われる
			const simulationShaderModule=dev.createShaderModule({
				label : "Game of Life simulation shader",
				code:`
					@group(0) @binding(0) var<uniform> grid:vec2f;
					
					@group(0) @binding(1) var<storage> cellStateIn:array<u32>;
					@group(0) @binding(2) var<storage,read_write>cellStateOut:array<u32>;

					fn cellIndex(cell : vec2u)->u32{
						return cell.y*u32(grid.x)+(cell.x%u32(grid.x));
					}
					fn cellActive(x:u32,y:u32)->u32{
						return cellStateIn[cellIndex(vec2(x,y))];
					}
					@compute
					@workgroup_size(${WORKGROUP_SIZE},${WORKGROUP_SIZE})
					fn computeMain(@builtin(global_invocation_id) cell : vec3u){
						let i=cellIndex(cell.xy);
						let activeNeighbors=cellActive(cell.x+1,cell.y+1)+
											cellActive(cell.x+1,cell.y)+
											cellActive(cell.x+1,cell.y-1)+
											cellActive(cell.x,cell.y+1)+
											cellActive(cell.x,cell.y-1)+
											cellActive(cell.x-1,cell.y+1)+
											cellActive(cell.x-1,cell.y)+
											cellActive(cell.x-1,cell.y-1);
						switch (activeNeighbors){
							case 2:{
								cellStateOut[i]=cellStateIn[i];
							}
							case 3:{
								cellStateOut[i]=1;
							}
							default:{
								cellStateOut[i]=0;
							}
						}

					}
				`
			});

			//レンダリングパイプラインを作成する
			//https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createRenderPipeline
			//
			//各種オブジェクトを設定していく。深度ステンシル、フラグメント(ピクセル)、ラベル、レイアウト(必須)、マルチサンプル、プリミティブ、バーテックス(頂点で必須)
			//に関するオブジェクトがある。
			//まずは今回は初回なので、必須のレイアウト、およびラベル(デバッグ用)、バーテックス、ピクセルのみ設定する
			//なお、レイアウトオブジェクトに関しては本来はcreatePipelineLayout()を使用して生成するが"auto"を指定しておけば、シェーダの内容から
			//内部的に自動で生成してくれるため、今回はこれを利用します。
			//
			//vertexオブジェクト構造体
			//https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createRenderPipeline#vertex_object_structure
			//
			//fragmentオブジェクト構造体
			//https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createRenderPipeline#fragment_object_structure





			//コンピュートシェーダ用バインドグループレイアウト
			//buffer.typeに関しては
			//https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createBindGroupLayout#type
			//を参照の事。それぞれバッファの種別を表しており、文字列は決め打ちである。
			//正直「enum的なものでよくない？」とは思う。
			//"read-only-storage"は読み取り専用のバッファ→GPUでの書き込みはできない
			//"storage"はストレージバッファのこと。ComputeShaderから書き込まれる事が期待される
			//無印の場合は"uniform"であり、定数バッファ扱いとなる(書き込み不可)
			const bindGroupLayout = dev.createBindGroupLayout({
				label:"Cell Bind Group Layout",
				entries:[
				{
					binding:0,
					visibility:GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
					buffer:{}
				},
				{
					binding:1,
					visibility:GPUShaderStage.VERTEX | GPUShaderStage.COMPUTE,
					buffer:{type:"read-only-storage"}				
				},
				{
					binding:2,
					visibility:GPUShaderStage.COMPUTE,
					buffer:{type:"storage"}
				}
				]
				
			});
			//ここまではautoで済んでいたがcomputeshaderと組み合わせるとなると、自前で
			//パイプラインレイアウトを作る事になる
			const pipelineLayout=dev.createPipelineLayout({
				label : "Cell Pipeline Layout",
				bindGroupLayouts:[bindGroupLayout]
			});

			
			const cellPipeline = dev.createRenderPipeline({
				label : "second test pipeline",
				layout : pipelineLayout,
				vertex : {
					module : cellShaderModule,//WGSLオブジェクト
					entryPoint : "vertexMain",//エントリポイント(頂点シェーダ実行時に最初に呼ばれる関数、main関数のようなもの)
					buffers:[vertexBufferLayout]//buffers属性という名前なのだが、頂点レイアウトが入る
				},
				fragment:{
					module:cellShaderModule,
					entryPoint:"fragmentMain",//ピクセルシェーダのエントリポイント
					targets:[{
						format:canvasFormat//出力先のフォーマット(キャンバスのフォーマットにしておく)
					}]
				}
			});

			//コンピュートシェーダ用パイプラインの作成
			const simulationPipeline=dev.createComputePipeline({
				label:"Simulation pipeline",
				layout:pipelineLayout,
				compute:{
					module : simulationShaderModule,
					entryPoint : "computeMain"
				}

			});
			
			//バインドグループの作成(シェーダ内のgroupやbindingと対応)
			//https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createBindGroup
			const bindGroups = [
				dev.createBindGroup({
					label : "Cell renderer bind group A",
					layout : bindGroupLayout,//cellPipeline.getBindGroupLayout(0),
					entries : [{
						binding:0,
						resource:{buffer:uniformBuffer}
					},
					{
						binding:1,
						resource:{buffer:cellStateStorages[0]}
					},
					{
						binding:2,
						resource:{buffer:cellStateStorages[1]}
					}
					]
				}),
				dev.createBindGroup({
					label : "Cell renderer bind group B",
					layout : bindGroupLayout,//cellPipeline.getBindGroupLayout(0),
					entries : [{
						binding:0,
						resource:{buffer:uniformBuffer}
					},
					{
						binding:1,
						resource:{buffer:cellStateStorages[1]}
					},
					{
						binding:2,
						resource:{buffer:cellStateStorages[0]}
					}
					]
				}),
			];




			//さて、この得られたデバイスとブラウザのキャンバスフォーマットを用いて
			///WebGPUレンダリングに必要な設定を行います。
			//https://developer.mozilla.org/en-US/docs/Web/API/GPUCanvasContext/configure
			context.configure(
				{
					device : dev,
					format : canvasFormat
				}
			);

			//これはWebGPU関係ないJavaScriptの関数です
			//https://developer.mozilla.org/ja/docs/Web/API/setInterval
			setInterval(updateGrid,UPDATE_INTERVAL);
			function updateGrid(){
				const encoder=dev.createCommandEncoder();

				const computePass = encoder.beginComputePass();
				computePass.setPipeline(simulationPipeline);
				computePass.setBindGroup(0,bindGroups[step%2]);
				const workgroupCount = Math.ceil(GRID_SIZE/WORKGROUP_SIZE);
				computePass.dispatchWorkgroups(workgroupCount,workgroupCount);
				computePass.end();

				step++;
				//コマンドエンコーダの作成(DirectX12でいうCommandQueue+CommandList的なモノかな)
				//https://developer.mozilla.org/en-US/docs/Web/API/GPUDevice/createCommandEncoder
				

				//レンダーパスなんてあったんや・・・
				//実はDirectX12にもあった
				//https://learn.microsoft.com/ja-jp/windows/win32/direct3d12/direct3d-12-render-passes
				//https://developer.mozilla.org/en-US/docs/Web/API/GPUCommandEncoder/beginRenderPass
				//色構造体と、深度ステンシル構造体を設定する(他はオプショナル)
				//3Dじゃないなら、深度ステンシルもオプショナル
				const pass = encoder.beginRenderPass(
					{
						colorAttachments:[
							{
								//このカラーアタッチメントの出力先がviewにあたる
								//これは恐らく現在のバックバッファやろなぁ
								view : context.getCurrentTexture().createView(),
								//レンダーパスを実行する「前」のロード操作
								loadOp : "clear",//このアタッチメントのクリア値をレンダーパスにロード
												//"load"だったら既存の値をロード
												//=レンダリングパスの開始時にテクスチャをクリア

								
								clearValue:{r:0.5,g:0,b:0.5,a:1},

								//レンダーパスを実行した「後」のストア操作
								storeOp : "store" // このアタッチメントのレンダーパスの値を格納
												//"discard"の場合はレンダーパスの結果を破棄
												//=レンダリングパスが終了するとレンダリングパス中二行われた描画の結果をテクスチャに保存

							}
						]
					}
				);
				pass.setPipeline(cellPipeline);//パイプラインのセット
				pass.setVertexBuffer(0,vertexBuffer);//頂点バッファのセット(第一引数はスロット番号)

				pass.setBindGroup(0,bindGroups[step%2]);

				pass.draw(vertices.length/2,GRID_SIZE*GRID_SIZE);//セットされている頂点を、指定したパイプライン設定で描画

				pass.end();//レンダリングパスを終了

				const commandBuffer=encoder.finish();//コマンドエンコーダの終了(とともにコマンドバッファを生成)
				dev.queue.submit([commandBuffer]);//そのコマンドバッファをコマンドキューに乗せ、GPU側に送信する
													//なお、この関数自体は複数のコマンドバッファを想定しているため
													//配列(コレクション)として送信する必要がある	
			}

		</script>
	</body>
</html>